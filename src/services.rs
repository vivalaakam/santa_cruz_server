use chrono :: { DateTime , Utc } ; use sqlx :: { PgPool , Row } ; use sqlx :: postgres :: PgRow ; use tonic :: { Request , Response , Status } ; use crate :: Queryable ; use crate :: query_builder :: QueryBuilder ;
pub mod exercise { use super :: * ; use crate :: proto :: proto :: santa_cruz :: Exercise ; impl From < PgRow > for Exercise { fn from (row : PgRow) -> Self { Exercise { id : row . get :: < i32 , _ > ("id") , created_at : row . get :: < DateTime < Utc > , _ > ("created_at") . to_rfc3339 () , updated_at : row . get :: < DateTime < Utc > , _ > ("updated_at") . to_rfc3339 () , name : row . get :: < String , _ > ("name") , description : row . get :: < String , _ > ("description") , } } } impl Queryable for Exercise { fn fields () -> Vec < & 'static str > { vec ! ["id" , "created_at" , "updated_at" , "name" , "description" ,] } fn table () -> & 'static str { "exercises" } fn query () -> QueryBuilder { let mut query = QueryBuilder :: new (Exercise :: table ()) ; query . fields (Exercise :: fields ()) ; query } } pub struct ExerciseService { pool : PgPool , } impl ExerciseService { pub fn new (pool : & PgPool) -> Self { ExerciseService { pool : pool . clone () } } pub async fn get_exercise_by_id (pool : & PgPool , id : i32 , user_id : i32 ,) -> Option < Exercise > { let mut query_builder = Exercise :: query () ; query_builder . where_raw ("((permissions ->> CAST(${index} as text))::integer > 0 OR (permissions ->> '0')::integer > 0)" , user_id) ; query_builder . where_eq ("id" , id) ; let sql = query_builder . select_query () ; sqlx :: query_with (sql . 0 . as_str () , sql . 1) . fetch_one (pool) . await . map (| r | r . into ()) . ok () } pub async fn return_exercise_by_id (& self , id : i32 , user_id : i32 ,) -> Result < Response < Exercise > , Status > { ExerciseService :: get_exercise_by_id (& self . pool , id , user_id) . await . map (| reply | Response :: new (reply)) . ok_or (Status :: not_found (format ! ("object #{} not found" , id . to_string ()))) } } }